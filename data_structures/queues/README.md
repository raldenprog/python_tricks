Описание и примеры кода в этом модуля взяты из книги: Чистый python, тонкости программироания лдя профи, Дэн Бейдер
# Очереди

## Очередь на основе list / list_queue
list — ужасно меееедленная очередь
В качестве очереди можно использовать обычный список, но с точки
зрения производительности такое решение не идеально. Списки для
этой цели довольно медленные, потому что вставка в начало очереди или
удаление элемента влекут за собой сдвиг всех других элементов на одну
позицию, требуя O(n) времени.

## Очередь на основе deque / deque_queue
collections.deque — быстрые и надежные очереди
Класс deque реализует очередь с двусторонним доступом, которая под-
держивает добавление и удаление элементов с любого конца за O(1)
(неамортизируемое) время. Поскольку двусторонние очереди одинаково
хорошо поддерживают добавление и удаление элементов с любого конца,
они могут служить в качестве очередей и в качестве стеков.
Объекты Python deque реализованы как двунаправленные связные списки
(doubly-linked lists). Это придает им превосходную и стабильную произ-
водительность для операций вставки и удаления элементов, но при этом
плохую O(n) производительность для произвольного доступа к элементам
в середине очереди.
Как результат, двусторонняя очередь collections.deque будет хорошим
выбором, если вы ищете структуру данных очередь в стандартной библио-
теке Python.

## Очередь на основе Queue / queue_queue
queue.Queue — семантика блокирования для параллельных вычислений
Данная реализация очереди в стандартной библиотеке Python синхро-
низирована и обеспечивает семантику блокирования с целью поддержки
многочисленных параллельных производителей и потребителей.
Модуль queue содержит несколько других классов, которые реализуют
очереди с мультипроизводителями/мультипотребителями, которые ши-
роко используются в параллельных вычислениях.
В зависимости от вашего варианта использования семантика блокирова-
ния может оказаться полезной, а может накладывать ненужные издержки.
В этом случае в качестве очереди общего назначения лучше всего исполь-
зовать двустороннюю очередь collections.deque.

## Очередь совместных заданий / multiprocessing_queue
multiprocessing.Queue — очереди совместных заданий
Такая реализация очереди совместных заданий позволяет выполнять па-
раллельную обработку находящихся в очереди элементов многочисленны-
ми параллельными рабочими процессами. Процессно-ориентированное
распараллеливание популярно в Python из-за глобальной блокировки
интерпретатора (GIL), которая препятствует некоторым формам парал-
лельного исполнения в единственном процессе интерпретатора.
В качестве специализированной реализации очереди, предназначенной
для обмена данными между процессами, очередь multiprocessing.Queue
упрощает распределение работы по многочисленным процессам с целью
преодоления ограничений GIL. Этот тип очереди может хранить и пере-
давать любой консервируемый (модулем pickle) объект через границы
процессов.


# Очереди с приоритетом
Очередь с приоритетом представляет собой контейнерную структуру дан-
ных, которая управляет набором записей с полностью упорядоченными
ключами (например, числовым значением веса) с целью обеспечения бы-
строго доступа к записи с наименьшим или наибольшим ключом в наборе.
Очередь с приоритетом можно представить как видоизмененную очередь:
вместо получения следующего элемента по времени вставки она получает
элемент с самым высоким приоритетом. Приоритет отдельных элементов
определяется примененным к их ключам упорядочение

## Очередь с приоритетом на основе list / list_priority_queue
list — поддержание сортируемой очереди вручную
Вы можете использовать сортированный список list, который позволяет
быстро идентифицировать и удалять наименьший или наибольший эле-
мент. Недостатком является то, что вставка новых элементов в список
является медленной O(n) операцией.
Несмотря на то что точка вставки может быть найдена за O(log n) время
с помощью алгоритма bisect.insort стандартной библиотеки, это реше-
ние всегда находится во власти медленного шага вставки.
Поддержание упорядоченности путем добавления в конец списка и пере-
сортировки также занимает минимум O(n log n) времени. Еще один недо-
статок — вам придется вручную заботиться о пересортировке списка во
время вставки новых элементов. Пропустив этот шаг, можно легко внести
ошибки, и ответственность за них всегда будет на вас как на разработчике.

## Двоичные кучи на основе списка heapq / heapq_priority_queue
Данная реализация двоичной кучи обычно подкрепляется обыкновенным
списком, и она поддерживает вставку и извлечение наименьшего элемента
за O(log n) время.
Этот модуль — хороший выбор для реализации очередей с приоритетом
в Python. Поскольку двоичная куча heapq технически обеспечивает толь-
ко реализацию min-heap (то есть кучи, где значение в любой вершине не
больше, чем значения ее потомков), должны быть предприняты допол-
нительные шаги, которые обеспечат стабильность сортировки и другие
функциональные возможности, которые, как правило, ожидают от «прак-
тической версии» очереди с приоритетом.

## Красивые очереди с приоритетом / beautiful_priority_queue
queue.PriorityQueue
Данная реализация очереди с приоритетом во внутреннем представлении
использует двоичную кучу heapq и имеет одинаковую временную и про-
странственную вычислительную сложность.
Разница состоит в том, что очередь с приоритетом PriorityQueue синхро-
низирована и обеспечивает семантику блокирования с целью поддержки
многочисленных параллельных производителей и потребителей.
В зависимости от вашего варианта использования она либо станет по-
лезной, либо слегка замедлит вашу программу. В любом случае вы мо-
жете предпочесть интерфейс на основе класса, предлагаемый классом
PriorityQueue, использованию интерфейса на основе функций, предла-
гаемого модулем heapq.

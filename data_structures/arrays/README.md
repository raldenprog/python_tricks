Описание и примеры кода в этом модуля взяты из книги: Чистый python, тонкости программироания лдя профи, Дэн Бейдер
# Массивоподобные структуры данных

## Изменяемые динамические массивы / list
Списки (lists) являются составной частью ядра языка Python. Несмотря
на свое имя, списки Python реализованы как динамические массивы. Это
означает, что список допускает добавление и удаление элементов и автоматически корректирует резервное хранилище, 
в котором эти элементы содержатся, путем выделения или высвобождения оперативной памяти.
Списки Python могут содержать произвольные элементы — в Python
абсолютно «всё» является объектом, включая и функции. Поэтому вы
можете сочетать и комбинировать разные типы данных и хранить их все в одном списке.
Такая возможность может быть очень мощной, но у нее есть и обратная
сторона: поддержка многочисленных типов данных одновременно означает, что данные, как правило, 
упакованы менее плотно. И в результате вся структура занимает больше места.

## Неизменяемые контейнеры / tuple
Аналогично спискам, кортежи тоже являются составной частью ядра
языка Python. Однако в отличие от списков, в Python объекты-кортежи
не изменяются. Это означает, что элементы не могут динамически добавляться или удаляться — все элементы в 
кортеже должны быть определены во время создания.
Точно так же, как и списки, кортежи могут содержать элементы произвольных типов данных. В этой гибкости много 
мощности, но, опять-таки, это также означает, что данные упакованы менее плотно, чем это было бы
в типизированном массиве.

## Именованные неизменяемые контейнеры / named_tuple
Класс namedtuple, доступный в Python 2.6+, предоставляет расширение
встроенного типа данных tuple. Аналогично определению собственного
класса, применение именованного кортежа namedtuple позволяет опре-
делять «шаблоны» многократного использования для своих записей,
гарантирующие использование правильных имен полей.
Именованные кортежи неизменяемы, как и обычные кортежи. Это означа-
ет, что вы не можете добавлять новые поля или изменять существующие
поля после того, как экземпляр namedtuple был создан.
Помимо этого, именованные кортежи являются, скажем так, именован-
ными кортежами (named tuples). Доступ к каждому хранящемуся в них
объекту можно получить по уникальному идентификатору. Это освобож-
дает от необходимости запоминать целочисленные индексы или идти
обходными методами, например определять индексы целочисленных
констант в качестве мнемокодов.
На внутреннем уровне объекты namedtuple реализованы как обычные
классы Python. В том, что касается использования оперативной памяти,
они тоже «лучше» обычных классов и столь же эффективны с точки зре-
ния потребляемой оперативной памяти, что и обычные кортежи:

## Элементарные типизированные массивы / array
Модуль Python array обеспечивает пространственно-эффективное хранение элементарных типов данных в стиле языка C, 
таких как байты, 32-разрядные целые числа, числа с плавающей точкой и т. д.
Массивы, создаваемые на основе класса array.array, могут изменяться и ведут себя аналогично спискам, 
за исключением одного важного различия — они являются «типизированными массивами», ограниченными
единственным типом данных.
Из-за этого ограничения объекты array.array со многими элементами
более пространственно эффективны, чем списки и кортежи. Хранящиеся
в них элементы плотно упакованы, и это может быть полезно, если вам
нужно хранить много элементов одного и того же типа.
Кроме того, массивы поддерживают многие из тех же методов, что и у
обычных списков, и вы можете их использовать в качестве «прямой замены» без необходимости вносить 
в свой код другие изменения.

## str - неизменяемые массивы символов Юникода / string_array
В Python 3.x объекты строкового типа str используются для хранения
текстовых данных в виде неизменяемых последовательностей символов
Юникода. В сущности, это означает, что тип str представляет собой
неизменяемый массив символов. Как это ни странно, но тип str также
является рекурсивной структурой данных: каждый символ в строке сам
является объектом str длиной, равной 1.
Строковые объекты пространственно эффективны, потому что они плотно
упакованы и специализируются на одном-единственном типе данных.
Если вы храните текст в кодировке Юникод, то лучше использовать этот
тип данных. Поскольку строки в Python не могут изменяться, модифи-
кация строкового значения требует создания модифицированной копии.
Самым близким эквивалентом «изменяющейся последовательности
символов» будет список, в котором символы хранятся по отдельности.

## bytes - неизменяемые массивы одиночных байтов / bytes
Объекты bytes представляют собой неизменяемые последовательности
одиночных байтов (целых чисел в диапазоне 0 ≤ x ≤ 255). В концептуаль-
ном плане они подобны объектам str и их также можно представить как
неизменяемые массивы байтов.
Аналогично строковому типу, тип bytes имеет свой собственный лите-
ральный синтаксис, предназначенный для создания объектов, и объекты
этого типа пространственно эффективны. Объекты bytes не могут изме-
няться, но, в отличие от строковых объектов, для «изменяемых массивов
байтов» есть специальный тип данных, который называется bytearray,
или байтовый массив, в который они могут быть распакованы. Вы узнаете
о нем подробнее в следующем подразделе.

## bytearray — изменяемые массивы одиночных байтов / byte_array
Тип bytearray представляет собой изменяемую последовательность целых
чисел в диапазоне 0 ≤ x ≤ 255. Они тесно связаны с объектами bytes, при
этом главное их отличие в том, что объекты bytearray можно свободно
изменять — вы можете переписывать элементы, удалять существующие
элементы или добавлять новые. Объект bytearray будет соответствующим
образом расти и сжиматься.
Объекты bytearray могут быть преобразованы обратно в неизменяе-
мые объекты bytes, но это влечет за собой копирование абсолютно всех
хранящихся в них данных — весьма медленная операция, занимающая
O(n) времени.

## Сериализованные С-структуры / struct
Класс struct.Struct1 выполняет преобразование между значениями
Python и структурами C, сериализованными в форму объектов Python
bytes. Например, он может использоваться для обработки двоичных
данных, хранящихся в файлах или поступающих из сетевых соединений.
Структуры Struct определяются с использованием форматного строко-
подобного мини-языка, который позволяет определять расположение
различных типов данных C, таких как char, int и long, а также их без-
знаковых вариантов.
Сериализованные структуры редко используются для представления объ-
ектов данных, предназначенных для обработки исключительно внутри
кода Python. Они нужны в первую очередь в качестве формата обмена
данными, а не как способ их хранения в оперативной памяти, применяе-
мый только программным кодом Python.
В некоторых случаях упаковка примитивных данных в структуры по-
зволяет уменьшить объем потребляемой оперативной памяти, чем их
хранение в других типах данных. Однако чаще всего такая работа будет
довольно продвинутой (и, вероятно, ненужной) оптимизацией.

"""
Декораторы позволяют определять конструктивные блоки многократного использования,
которые могут изменять или расширять поведение других функций.
И они позволяют это делать без необратимых изменений самой обернутой функции.
Поведение функции изменяется, только когда оно декорировано.

Декоратор functools.wraps можно использовать в своих собственных декораторах для того,
чтобы копировать потерянные метаданные из недекорированной функции в замыкание декоратора.
"""

import functools


def proxy(func):
    """
    Декоратор
    Args:
        func (func): декорируемая функция

    Returns:
        func
    """

    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        """
        Текстовый докстринг обертки, но он не будет занаследован,
        так как используем functools
        *args - расповка позиционных аргументов
        **kwargs - распаковка именованных аргументов
        Returns:
            func
        """
        print(f'Позиционные аргументы {args}')
        print(f'Именованные аргументы {kwargs}')
        return func(*args, **kwargs)

    return wrapper


@proxy
def print_message(msg, author):
    """Вернуть дружеское приветствие."""
    print(f'{msg} от {author}')


print_message('Привет', author='Me')
print(print_message.__doc__)  # Вернет докстринг декорируемой функции, а не декоратора
